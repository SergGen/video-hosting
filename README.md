# Как создать поток видеоданных с помощью Node.js

Источник [highload.today](https://highload.today/blogs/kak-sozdat-potok-videodannyh-s-pomoshhyu-node-js-razbirayu-detali-na-svoem-proekte/)

Представленный тут код имеет небольшие исправления, улучшения и дополнения в отличие от оригинала кода, представленного в статье.

## Файл index.js

Здесь создан простой сервер, функцией обратного вызова назначена функция `router`, получающая параметры `request` и `response`. Далее проверяется, имеется ли по полученному `request.url` совпадению в объекте `runnersByRouts` по данному имени ключа. Если да — то вызывается соответствующая функция, если нет — то возвращается ответ об ошибке к клиенту.
При открытии вкладки в браузере по ссылке на сервер поступает запрос с `url` `/` и сервер отдаёт файл `index.html`.

## Файл modules/send-home-page.mjs

Сначала находится путь к файлу `index.html` с помощью `resolve(__dirname, '..', 'public', 'index.html')`, назначается тип контента, который собирается отправляться клиенту `res.setHeader('Content-Type', 'text/html')`, далее создаётся читаемый поток `fs.createReadStream(pathHomePage)`, и на последней строке вызывается поток с помощью функции `pipeline()`.

## Файл modules/send-image.mjs

Сначала находится путь к файлу `img.jpg` с помощью `resolve(__dirname, '..', 'public', 'img.jpg')`, назначается тип контента, который собирается отправляться клиенту `res.setHeader('Content-Type', 'image/jpeg')`, далее создаётся читаемый поток `fs.createReadStream(pathImg)`, и на последней строке вызывается поток с помощью функции `pipeline()`.

## Файл index.html

Несколько важных атрибутов в html-элементе `<video>`:

- `src="/video-stream"` — при рендеринге страницы в браузере клиент обращается к серверу по адресу `http://localhost:8000/video-stream` и получает видео.
- `controls` — этот атрибут позволяет пользователю иметь контроль над видео (старт/пауза, звук и т.п.).
- `preload="auto"` — в спецификации указано, что весь видеофайл может загрузиться даже если пользователь не будет использовать его. Но на практике всё зависит от браузера и будет происходить скорее всего более динамично. Например, да — ваше видео будет загружено примерно на 1 мин. наперед и через каждые 5 секунд воспроизведенного видео дозагрузятся еще 5 секунд и т.д.

Поэтому на сервер поступает запрос с `url` `/video-stream` и мы вызывается функция `sendVideoFile`.

## Файл modules/send-video-file.mjs

В функции `sendVideoFile` всё начинается с того, что:

1. Создаётся абсолютный путь к файлу — путь, который указан в параметре `pathToVideo`. Было `public/video.mp4` — стало `/your_folder/your_folder/project_folder/public/video.mp4`.
2. `fs.statSync(resolvedPath).size` — определяется размер файла в байтах.
3. `req.headers.range` — получается параметр `range` `(bytes=12582912-)`, то есть то, с какой позиции нужно скачивать видео в байтах.

В зависимости от браузера и проигрывателя параметр `range` может быть `null` или, например, `bytes=123456-`, поэтому есть две различные функции для обработки этих на самом деле разных подходов.

## Файл modules/create-video-stream.mjs

Здесь уже всё просто — код схож с тем, который рассматривался в `modules/send-home-page.mjs`. Единственная разница в том, что назначаются обязательные заголовки `Content-Type` и `Content-Length` для того, чтобы браузер понимал, какого типа сервер посылает ему информацию и какого размера. Это необходимо как для корректной работы проигрывателя, так и для дальнейшего взаимодействия проигрывателя с сервером во время последующих транзакций данных.

И внизу также один из самых частых случаев — когда параметр `range` существует.

## Файл modules/create-video-stream-by-range.mjs

Здесь есть функция getChunkData, которая принимает входящий параметр range и fileSize осуществляет следующие шаги:

1. Берет пару значений из `range = bytes=36634624-` и получает массив `parts = [ '36634624', '' ]`.
2. Вычисляет значение `start = 36896768`, `end = 86890916`, `chunkSize = 49994149`.

## Файл modules/get-chunk-data.js

Также в `createVideoStreamByRange` указывается обязательным статус ответа `206`, а также `Content-Range` — какую часть данных со всего видео сервер отправляет, а также `Accept-Ranges` — в каком формате данные, которые сервер отправляет.

Еще несколько дополнений, которые полезно знать:

1. `pipeline` почему лучше использовать `pipeline()`, а не очередь `pipe()` при работе с потоками. В функции `pipeline()` последний аргумент — функция обратного вызова. Она использовалась в вышеперечисленных примерах кода. Если возникнет ошибка в любом из переданных потоков, то она может быть обработана в одном месте. Также `pipeline()` самостоятельно закрывает все оконченные, но не закрытые запросы к серверу. Например, когда используется `someReadStream(path).pipe(res)`, то после ошибки или окончания передачи данных запрос на сервер скорее всего не закроет, из-за чего возникают непонятные и очень веские ошибки и потеря оперативной памяти. Об этом можно почитать подробнее [здесь](https://nodejs.org/api/stream.html#streampipelinesource-transforms-destination-callback).
2. `highWaterMark` — это значение размера внутреннего буфера, то есть количество данных в байтах, которые сервер может прочитать за один раз, то есть один `chunk` данных (по умолчанию он `64kB`). Также значение `highWaterMark` можно изменить при создании потока `fs.createReadStream(path, { highWaterMark: 2 })`, теперь сервер считывает файл для отправки клиенту по два символа за раз. Также можно узнать размер `highWaterMark` следующим образом: `readStream.readableHighWaterMark`. Его значение по умолчанию будет `65536` байтов.

## Как работает поток и отправка данных в деталях?

Сначала сервером создается поток по считыванию файла, который назначается его в смену `readStream`, после этого используется его в функции `pipeline()`, далее `chunk` данных передаётся к потоку `res` (т.е. `response`, если полностью) и тогда `res` его получает и отправляет клиенту с помощью `res.write(chunk)`. Каждый раз когда сервер читает и передаёт ему `chunk` данные, то в конце, когда уже нет данных для считывания, вызывается событие `end` для каждого потока и функция `pipeline()` самостоятельно закрывает их. Что очень важно, в случае `res` после последнего вызывается `res.end()` и запрос к серверу успешно заканчивается.